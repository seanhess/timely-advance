# https://vadosware.io/post/zero-to-continuous-integrated-testing-a-haskell-project-with-gitlab/
# Caching! https://docs.gitlab.com/ee/ci/yaml/README.html#cache
# https://docs.gitlab.com/ee/ci/docker/using_docker_build.html
# https://angristan.xyz/build-push-docker-images-gitlab-ci/

# this should match stack.yaml
# image: fpco/stack-build:lts-13.7
# image: haskell:8
# image: docker:stable


# TODO: docker (for uploading)
# TODO: make my own image? with haskell:8, node, etc?

# before_scripte
#   - docker info


# before_script:
#   - apt-get update -y


# The goal is produce docker containers
# don't do it this way

# these stages should match the pipeline
stages:
  - build
  # - test
  - deploy


# TODO - use the docker image to build
# you can't use the same version for both... not without doing it in the same deply stage. ok
build-elm:
  stage: build
  before_script:
    - docker --version
  cache:
    paths:
      - web/elm-stuff
  script:
    - docker build -t $IMAGE_WEB:$RELEASE web



build:
  stage: build
  before_script:
    - docker --version
    - stack --version
  script:
    - cd server
    - echo "module Version where version = \"$RELEASE\"" > src/Version.hs
    - cat src/Version.hs
    - stack docker pull
    - stack setup --docker
    - stack build --docker --test


# test:
#   stage: test
#   script:
#     - cd server
#     - stack test --docker


deploy:
  stage: deploy
  before_script:
    # - docker login -u sean.hess -p mbPGDyQUsyC2BG28x1wa $CI_REGISTRY
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  script:
    - cd server
    - stack image container --docker
    - docker tag timely:latest $IMAGE_SERVER:$RELEASE
    - docker push $IMAGE_SERVER:$RELEASE
    - docker push $IMAGE_WEB:$RELEASE

cache:
  paths:
    - .stack
    - server/.stack-work

variables:
  STACK_ROOT: "${CI_PROJECT_DIR}/.stack"
  VERSION: "0.2"
  RELEASE: "$VERSION.$CI_COMMIT_SHORT_SHA"
  IMAGE_SERVER: "$CI_REGISTRY/timely-advance/timely"
  IMAGE_WEB:    "$CI_REGISTRY/timely-advance/timely/web"
